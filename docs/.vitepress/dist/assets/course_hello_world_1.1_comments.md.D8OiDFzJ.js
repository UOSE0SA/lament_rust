import{_ as i,c as a,o as n,ae as e}from"./chunks/framework.C7kf6YPw.js";const c=JSON.parse('{"title":"1.1 注释 (comments)","description":"","frontmatter":{},"headers":[],"relativePath":"course/hello_world/1.1_comments.md","filePath":"course/hello_world/1.1_comments.md"}'),t={name:"course/hello_world/1.1_comments.md"};function l(p,s,h,o,k,r){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="_1-1-注释-comments" tabindex="-1">1.1 注释 (comments) <a class="header-anchor" href="#_1-1-注释-comments" aria-label="Permalink to &quot;1.1 注释 (comments)&quot;">​</a></h1><blockquote><p><a href="https://doc.rust-lang.org/reference/comments.html" target="_blank" rel="noreferrer">官方文档</a></p></blockquote><h3 id="什么是注释" tabindex="-1">什么是注释? <a class="header-anchor" href="#什么是注释" aria-label="Permalink to &quot;什么是注释?&quot;">​</a></h3><p>注释就是对代码的解释和说明，其目的是让人们能够更加轻松地了解代码。注释是编写程序时，写程序的人给一个语句、程序段、函数等的解释或提示，能提高程序代码的可读性。</p><p>注释只是为了提高可读性，不会被计算机编译。</p><h3 id="rust中的注释" tabindex="-1">Rust中的注释 <a class="header-anchor" href="#rust中的注释" aria-label="Permalink to &quot;Rust中的注释&quot;">​</a></h3><h4 id="非文档注释" tabindex="-1">非文档注释 <a class="header-anchor" href="#非文档注释" aria-label="Permalink to &quot;非文档注释&quot;">​</a></h4><blockquote><p><em>原文:<a href="https://doc.rust-lang.org/reference/comments.html#non-doc-comments" target="_blank" rel="noreferrer"> Non-doc comments</a></em></p><p><em>Comments follow the general C++ style of line () and block () comment forms. Nested block comments are supported.<code>//\`\`/* ... */</code></em></p><p><em>Non-doc comments are interpreted as a form of whitespace.</em></p></blockquote><p>注释遵循 C++ 的通用风格，包括行注释（<code>//</code>）和块注释（<code>/* ... */</code>）形式。支持嵌套块注释。<code>// /* ... */</code></p><p>非文档注释会被解释为一种空白符。</p><p>我们知道注释只为了可读性，不会被编译，在Rust中，行注释是这样写的：</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这是一个注释</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  println!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, world!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>但是，除了举例子，我们一般不会写这样的~~（没用）~~行注释，可以参照下面的事项：</p><div class="caution custom-block github-alert"><p class="custom-block-title">CAUTION</p><p></p><p>避免逐行注释，应编写聚焦于“为什么”的注释，而不是“是什么”</p></div><p>好的例子:</p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><h6 id="源文件" tabindex="-1">源文件 <a class="header-anchor" href="#源文件" aria-label="Permalink to &quot;源文件&quot;">​</a></h6><p>Zip File: <a href="../src/hello_world/1.1/row_comment/zip/row_comment.zip" download><strong>点击我下载</strong></a></p><p>Markdown Link: <a href="/lament_rust/src/hello_world/1.1/row_comment/md/row_comment.html">Markdown</a></p></div><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> n </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> i32</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    println!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;The {}th Fibonacci number is {}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, n, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fibonacci_sequence</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fibonacci_sequence</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> i32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> i32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 计算斐波那契数列第index项，n=0或1时直接返回index</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        index</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        index</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        fibonacci_sequence</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fibonacci_sequence</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Rust本身没有特殊的TODO/FIXME语法，但开发者习惯用普通注释加这些关键词标记待办事项。比如：</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// TODO: 实现用户登录功能</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// FIXME: 此处存在性能瓶颈，需优化</span></span></code></pre></div><p>这样的注释能帮团队快速定位问题，很多编辑器（如VS Code、RustRover）还会自动标与其他注释不一样的颜色的提示！</p><h4 id="块注释" tabindex="-1">块注释 <a class="header-anchor" href="#块注释" aria-label="Permalink to &quot;块注释&quot;">​</a></h4><p>我们来看看块注释（被大部分人们称为多行注释）：</p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><h6 id="源文件-1" tabindex="-1">源文件 <a class="header-anchor" href="#源文件-1" aria-label="Permalink to &quot;源文件&quot;">​</a></h6><p>Zip File: <a href="../src/hello_world/1.1/row_comment/zip/row_comment.zip" download><strong>点击我下载</strong></a></p><p>Markdown Link: <a href="/lament_rust/src/hello_world/1.1/row_comment/md/row_comment.html">Markdown</a></p></div><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 错误写法:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">int main() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  println!(&quot;Hello, world!&quot;);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">这不是C++！！！</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">*/</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  println!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Hello, world!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>但是，Rust社区更倾向于行注释，块注释仅用于临时屏蔽代码最后我们看看文档注释.</p><blockquote><p><em>原文：</em><a href="https://doc.rust-lang.org/reference/comments.html#doc-comments" target="_blank" rel="noreferrer"> Doc comments</a></p><p>Line doc comments beginning with exactly <em>three</em> slashes (), and block doc comments (), both outer doc comments, are interpreted as a special syntax for <a href="https://doc.rust-lang.org/rustdoc/the-doc-attribute.html" target="_blank" rel="noreferrer"><code>doc</code> attributes</a>.<code>///\`\`/** ... */</code></p><p>That is, they are equivalent to writing around the body of the comment, i.e., turns into and turns into . They must therefore appear before something that accepts an outer attribute.<code>#[doc=&quot;...&quot;]\`\`/// Foo\`\`#[doc=&quot;Foo&quot;]\`\`/** Bar */\`\`#[doc=&quot;Bar&quot;]</code></p><p>Line comments beginning with and block comments are doc comments that apply to the parent of the comment, rather than the item that follows.<code>//!\`\`/*! ... */</code></p><p>That is, they are equivalent to writing around the body of the comment. comments are usually used to document modules that occupy a source file.<code>#![doc=&quot;...&quot;]\`\`//!</code></p><p>The character (CR) is not allowed in doc comments.<code>U+000D</code></p></blockquote><h3 id="文档注释" tabindex="-1">文档注释 <a class="header-anchor" href="#文档注释" aria-label="Permalink to &quot;文档注释&quot;">​</a></h3><p>以恰好三个斜杠（<code>///</code>）开头的行文档注释，以及块文档注释（<code>/** ... */</code>）——两者均为外部文档注释.</p><p>被解释为文档属性的特殊语法。<code>///</code> <code>/** ... */</code> 也就是说，它们等同于在注释主体周围添加 <code>#[doc=&quot;...&quot;]</code>，即 <code>/// Foo</code> 变为 <code>#[doc=&quot;Foo&quot;]</code>，<code>/** Bar */</code> 变为 <code>#[doc=&quot;Bar&quot;]</code>。因此，它们必须出现在接受外部属性的内容之前。 以 <code>//!</code> 开头的行注释和 <code>/*! ... */</code> 块注释是应用于注释父级而非后续项的文档注释。 也就是说，它们等同于在注释主体周围添加 <code>#![doc=&quot;...&quot;]</code>。<code>//!</code> 注释通常用于为占据源文件的模块添加文档。 文档注释中不允许出现 U+000D 字符（回车符）。</p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><p>按照惯例，文档注释通常包含 Markdown 格式的内容，这也是 <code>rustdoc</code> 工具所期望的。不过，注释语法并不考虑内部的 Markdown 结构。例如，<code>/** </code>glob = &quot;<em>/</em>.rs&quot;;<code> */</code> 会在遇到第一个 <code>*/</code> 时就终止注释，而剩余的代码会导致语法错误。与行文档注释相比，这对块文档注释的内容造成了一定限制。</p></div><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p></p><p>由 U+000D（回车符，CR）紧跟 U+000A（换行符，LF）组成的字符序列，此前会被转换为单个 U+000A（换行符，LF）。</p></div><p>例如这样的代码：</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// 计算两个整数的和。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// # 参数</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// - \`a\`：第一个加数。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// - \`b\`：第二个加数。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// # 返回值</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// 两个数的和。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// # 示例</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// \`\`\`rust</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// let result = add(2, 3);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// assert_eq!(result, 5);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/// \`\`\`</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> i32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> i32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> i32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>我们可以使用<code>cargo doc --open</code>生成文档</p><p>生成的文档在<code>target/doc/项目名称/index.html</code>中</p><h3 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h3><h5 id="我们应该如何编写一个好的注释" tabindex="-1">我们应该如何编写一个好的注释？ <a class="header-anchor" href="#我们应该如何编写一个好的注释" aria-label="Permalink to &quot;我们应该如何编写一个好的注释？&quot;">​</a></h5><p>• 不要过度注释：代码逻辑清晰时（如let sum = a + b;），无需注释。</p><p>• 注释与代码同步更新：修改代码后及时更新注释，避免“误导性注释”。</p><p>• 文档注释的风格统一：推荐使用标准库的格式（参数用# 参数，示例用代码块）。</p><h3 id="习题练习" tabindex="-1">习题练习 <a class="header-anchor" href="#习题练习" aria-label="Permalink to &quot;习题练习&quot;">​</a></h3><ol><li>分析Rust开源项目（如<code>rand</code>或<code>serde</code>）的注释风格。</li><li>查看rand库中rand::thread_rng函数的文档注释，模仿它的格式，给本节课的add函数补充更详细的注释。</li><li>尝试用cargo doc生成自己代码的文档</li></ol>`,42)]))}const g=i(t,[["render",l]]);export{c as __pageData,g as default};
